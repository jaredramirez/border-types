// Generated by BUCKLESCRIPT VERSION 3.1.5, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/lib/js/src/jest.js");
var Block = require("bs-platform/lib/js/block.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Decode$BorderTypes = require("../src/Decode.bs.js");

var NotEqual = Caml_exceptions.create("DecodeSpec-BorderTypes.NotEqual");

function expectToBe(value, expected) {
  if (Caml_obj.caml_equal(value, expected)) {
    return Jest.Expect[/* toEqual */12](true, Jest.Expect[/* expect */0](true));
  } else {
    throw [
          NotEqual,
          "Expected " + (String(value) + (" to equal " + String(expected)))
        ];
  }
}

describe("Decode", (function () {
        describe("Primitive", (function () {
                describe("should success", (function () {
                        Jest.test("to decode primitve string type", (function () {
                                var decoded = Decode$BorderTypes.Primitive[/* decode */9]("string");
                                return expectToBe(decoded, /* Ok */Block.variant("Ok", 0, [/* String */0]));
                              }));
                        Jest.test("to decode primitve int type", (function () {
                                var decoded = Decode$BorderTypes.Primitive[/* decode */9]("int");
                                return expectToBe(decoded, /* Ok */Block.variant("Ok", 0, [/* Int */1]));
                              }));
                        Jest.test("to decode primitve float type", (function () {
                                var decoded = Decode$BorderTypes.Primitive[/* decode */9]("float");
                                return expectToBe(decoded, /* Ok */Block.variant("Ok", 0, [/* Float */2]));
                              }));
                        Jest.test("to decode primitve bool type", (function () {
                                var decoded = Decode$BorderTypes.Primitive[/* decode */9]("bool");
                                return expectToBe(decoded, /* Ok */Block.variant("Ok", 0, [/* Bool */3]));
                              }));
                        Jest.test("to decode primitve unit type", (function () {
                                var decoded = Decode$BorderTypes.Primitive[/* decode */9](/* array */[]);
                                return expectToBe(decoded, /* Ok */Block.variant("Ok", 0, [/* Unit */4]));
                              }));
                        return Jest.test("to decode primitve list type", (function () {
                                      var decoded = Decode$BorderTypes.Primitive[/* decode */9](/* array */["string"]);
                                      return expectToBe(decoded, /* Ok */Block.variant("Ok", 0, [/* List */Block.variant("List", 0, [/* String */0])]));
                                    }));
                      }));
                return /* () */0;
              }));
        return /* () */0;
      }));

var R = 0;

exports.R = R;
exports.NotEqual = NotEqual;
exports.expectToBe = expectToBe;
/*  Not a pure module */
