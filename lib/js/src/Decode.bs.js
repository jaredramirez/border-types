// Generated by BUCKLESCRIPT VERSION 3.1.5, PLEASE EDIT WITH CARE
'use strict';

var Json = require("@glennsl/bs-json/lib/js/src/Json.bs.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Misc$BorderTypes = require("./Misc.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function decodeAsResult(decoder, json) {
  var exit = 0;
  var value;
  try {
    value = Curry._1(decoder, json);
    exit = 1;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Json.ParseError) {
      return /* Error */Block.variant("Error", 1, [exn[1]]);
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return /* Ok */Block.variant("Ok", 0, [value]);
  }
  
}

function stringDecoder(param) {
  return Json_decode.map((function (x) {
                return /* Str */Block.variant("Str", 0, [x]);
              }), Json_decode.string, param);
}

function listDecoder(subDecoder) {
  return (function (param) {
      return Json_decode.map((function (x) {
                    return /* List */Block.variant("List", 1, [x]);
                  }), (function (param) {
                    return Json_decode.list(subDecoder, param);
                  }), param);
    });
}

function dictDecoder(subDecoder) {
  return (function (param) {
      return Json_decode.map((function (x) {
                    return /* Dict */Block.variant("Dict", 2, [x]);
                  }), (function (param) {
                    return Json_decode.dict(subDecoder, param);
                  }), param);
    });
}

var stringValue = "string";

var intValue = "int";

var floatValue = "float";

var boolValue = "bool";

function decodeInternal(json) {
  var decoded = Json_decode.oneOf(/* :: */Block.simpleVariant("::", [
          stringDecoder,
          /* :: */Block.simpleVariant("::", [
              listDecoder(Misc$BorderTypes.identity),
              /* :: */Block.simpleVariant("::", [
                  dictDecoder(Misc$BorderTypes.identity),
                  /* [] */0
                ])
            ])
        ]), json);
  var exit = 0;
  var val;
  try {
    val = decoded;
    exit = 1;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Json.ParseError) {
      return /* Error */Block.variant("Error", 1, [/* ParseError */Block.variant("ParseError", 0, [exn[1]])]);
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    switch (val.tag | 0) {
      case 0 : 
          var str = val[0];
          if (str === stringValue) {
            return /* Ok */Block.variant("Ok", 0, [/* String */0]);
          } else if (str === intValue) {
            return /* Ok */Block.variant("Ok", 0, [/* Int */1]);
          } else if (str === floatValue) {
            return /* Ok */Block.variant("Ok", 0, [/* Float */2]);
          } else if (str === boolValue) {
            return /* Ok */Block.variant("Ok", 0, [/* Bool */3]);
          } else {
            return /* Error */Block.variant("Error", 1, [/* UnknownTypeError */Block.variant("UnknownTypeError", 1, [str])]);
          }
      case 1 : 
          var list = val[0];
          if (list) {
            if (list[1]) {
              return Misc$BorderTypes.mapErrorResult((function (x) {
                            return /* ListError */Block.variant("ListError", 2, [x]);
                          }), Misc$BorderTypes.mapResult((function (x) {
                                return /* Tuple */Block.variant("Tuple", 1, [x]);
                              }), Misc$BorderTypes.traverseListResults(decodeInternal, list)));
            } else {
              var listTypeDecoded = decodeInternal(list[0]);
              return Misc$BorderTypes.mapResult((function (x) {
                            return /* List */Block.variant("List", 0, [x]);
                          }), listTypeDecoded);
            }
          } else {
            return /* Ok */Block.variant("Ok", 0, [/* Unit */4]);
          }
      case 2 : 
          var match = List.split($$Array.to_list(Js_dict.entries(val[0])));
          var keys = match[0];
          var valuesDecoded = Misc$BorderTypes.traverseListResults(decodeInternal, match[1]);
          return Misc$BorderTypes.mapResult((function (actual) {
                        return /* Record */Block.variant("Record", 2, [Misc$BorderTypes.listToStringMap(List.combine(keys, actual))]);
                      }), valuesDecoded);
      
    }
  }
  
}

function errorToString(error) {
  switch (error.tag | 0) {
    case 0 : 
        return error[0];
    case 1 : 
        return "I was expecting one of \"" + (stringValue + ("\", \"" + (intValue + ("\", \"" + (floatValue + ("\", \"" + (boolValue + ("\", an object, or an array but got \"" + (error[0] + "\" instead.")))))))));
    case 2 : 
        return "I ran into an error decoding a list, x-tuple, or unit: " + errorToString(error[0]);
    case 3 : 
        return "I ran into an error decoding a record: " + errorToString(error[0]);
    
  }
}

function decode(json) {
  return Misc$BorderTypes.mapErrorResult(errorToString, decodeInternal(json));
}

var Primitive = /* module */Block.localModule([
    "stringDecoder",
    "listDecoder",
    "dictDecoder",
    "stringValue",
    "intValue",
    "floatValue",
    "boolValue",
    "decodeInternal",
    "errorToString",
    "decode"
  ], [
    stringDecoder,
    listDecoder,
    dictDecoder,
    stringValue,
    intValue,
    floatValue,
    boolValue,
    decodeInternal,
    errorToString,
    decode
  ]);

function startsWithCapitalLetter(str) {
  var exit = 0;
  var firstChar;
  try {
    firstChar = Caml_string.get(str, 1);
    exit = 1;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return false;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    if (firstChar > 64) {
      return firstChar < 91;
    } else {
      return false;
    }
  }
  
}

function containsInvalidChars(str) {
  var chars = Misc$BorderTypes.stringToList(str);
  return List.fold_right((function (cur, acc) {
                if (acc) {
                  return acc;
                } else if (cur === /* " " */32 || cur === /* "\n" */10) {
                  return true;
                } else {
                  return cur === /* "\r" */13;
                }
              }), chars, false);
}

function stringDecoder$1(param) {
  return Json_decode.map((function (x) {
                return /* Str */Block.variant("Str", 0, [x]);
              }), Json_decode.string, param);
}

function primitiveDecoder(param) {
  return Json_decode.map((function (x) {
                return /* PrimitiveType */Block.variant("PrimitiveType", 1, [x]);
              }), decode, param);
}

var nameKey = "name";

var kindUnionValue = "union";

var kindAliasValue = "alias";

var valueKey = "value";

var constructorsKey = "constructors";

function nameDecoder(json) {
  return Misc$BorderTypes.andThenResult((function (decodedName) {
                if (decodedName.length === 0) {
                  return /* Error */Block.variant("Error", 1, [/* InvalidNameError */Block.variant("InvalidNameError", 3, [
                                decodedName,
                                "not be an empty string"
                              ])]);
                } else if (startsWithCapitalLetter(decodedName)) {
                  if (containsInvalidChars(decodedName)) {
                    return /* Error */Block.variant("Error", 1, [/* InvalidNameError */Block.variant("InvalidNameError", 3, [
                                  decodedName,
                                  "contain any space or new line characters"
                                ])]);
                  } else {
                    return /* Ok */Block.variant("Ok", 0, [decodedName]);
                  }
                } else {
                  return /* Error */Block.variant("Error", 1, [/* InvalidNameError */Block.variant("InvalidNameError", 3, [
                                decodedName,
                                "start with a capital letter"
                              ])]);
                }
              }), Misc$BorderTypes.mapErrorResult((function (x) {
                    return /* ParseError */Block.variant("ParseError", 0, [x]);
                  }), decodeAsResult((function (param) {
                        return Json_decode.field(nameKey, Json_decode.string, param);
                      }), json)));
}

function kindDecoder(kind, json) {
  var expectedKind = kind ? kindAliasValue : kindUnionValue;
  return Misc$BorderTypes.andThenResult((function (decodedKind) {
                if (decodedKind !== expectedKind) {
                  return /* Error */Block.variant("Error", 1, [(function (optionName) {
                                return /* InvalidKindError */Block.variant("InvalidKindError", 4, [
                                          optionName,
                                          decodedKind
                                        ]);
                              })]);
                } else {
                  return /* Ok */Block.variant("Ok", 0, [/* () */0]);
                }
              }), Misc$BorderTypes.mapErrorResult((function (x, _) {
                    return /* ParseError */Block.variant("ParseError", 0, [x]);
                  }), decodeAsResult((function (param) {
                        return Json_decode.field(nameKey, Json_decode.string, param);
                      }), json)));
}

function aliasDecoder(json) {
  var decodedName = nameDecoder(json);
  var decodedKind = Misc$BorderTypes.mapErrorResult((function (makeError) {
          return Curry._1(makeError, Misc$BorderTypes.toOptionResult(decodedName));
        }), kindDecoder(/* Alias */1, json));
  var decodedValue = Misc$BorderTypes.mapErrorResult((function (x) {
          return /* ParseValueError */Block.variant("ParseValueError", 1, [
                    Misc$BorderTypes.toOptionResult(decodedName),
                    x
                  ]);
        }), Json_decode.field(valueKey, decode, json));
  return Misc$BorderTypes.map3Result((function (name, _, value) {
                return /* Alias */Block.variant("Alias", 0, [/* record */Block.record([
                              "name",
                              "value"
                            ], [
                              name,
                              value
                            ])]);
              }), decodedName, decodedKind, decodedValue);
}

function constructorsDecoder(customDecoder, json) {
  var listDecoder = function (param) {
    return Json_decode.map((function (result) {
                  return Misc$BorderTypes.andThenResult((function (param) {
                                return Misc$BorderTypes.traverseListResults(customDecoder, param);
                              }), Misc$BorderTypes.mapErrorResult((function (x) {
                                    return /* ParseError */Block.variant("ParseError", 0, [x]);
                                  }), result));
                }), (function (param) {
                  return decodeAsResult((function (param) {
                                return Json_decode.list(Misc$BorderTypes.identity, param);
                              }), param);
                }), param);
  };
  var param = json;
  return Json_decode.map((function (result) {
                return Misc$BorderTypes.andThenResult((function (dict) {
                              return Misc$BorderTypes.traverseMapResults(listDecoder, Misc$BorderTypes.dictToStringMap(dict));
                            }), Misc$BorderTypes.mapErrorResult((function (x) {
                                  return /* ParseError */Block.variant("ParseError", 0, [x]);
                                }), result));
              }), (function (param) {
                return decodeAsResult((function (param) {
                              return Json_decode.dict(Misc$BorderTypes.identity, param);
                            }), param);
              }), param);
}

function unionDecoder(customDecoder, json) {
  var decodedName = nameDecoder(json);
  var decodedKind = Misc$BorderTypes.mapErrorResult((function (makeError) {
          return Curry._1(makeError, Misc$BorderTypes.toOptionResult(decodedName));
        }), kindDecoder(/* Union */0, json));
  var decodedConstructors = Misc$BorderTypes.mapErrorResult((function (x) {
          return /* ParseConstructorError */Block.variant("ParseConstructorError", 2, [
                    Misc$BorderTypes.toOptionResult(decodedName),
                    x
                  ]);
        }), Json_decode.field(constructorsKey, (function (param) {
              return constructorsDecoder(customDecoder, param);
            }), json));
  return Misc$BorderTypes.map3Result((function (name, _, constructors) {
                return /* Union */Block.variant("Union", 1, [/* record */Block.record([
                              "name",
                              "constructors"
                            ], [
                              name,
                              constructors
                            ])]);
              }), decodedName, decodedKind, decodedConstructors);
}

function decodeInternal$1(json) {
  return Json_decode.oneOf(/* :: */Block.simpleVariant("::", [
                (function (param) {
                    return unionDecoder(decodeInternal$1, param);
                  }),
                /* :: */Block.simpleVariant("::", [
                    aliasDecoder,
                    /* [] */0
                  ])
              ]), json);
}

function errorToString$1(error) {
  switch (error.tag | 0) {
    case 0 : 
        return error[0];
    case 1 : 
        var prefix = Belt_Option.mapWithDefault(error[0], "a union type", (function (name) {
                return "the union type \"" + (name + "\"");
              }));
        return "While parsing " + (prefix + (", I ran into the following error: " + error[1]));
    case 2 : 
        var prefix$1 = Belt_Option.mapWithDefault(error[0], "a union type", (function (name) {
                return "the union type \"" + (name + "\"");
              }));
        return "While parsing " + (prefix$1 + (", I ran into the following error: " + errorToString$1(error[1])));
    case 3 : 
        return "While parsing the union type \"" + (error[0] + ("\" , I expected then \"name\" field to " + (error[1] + ".")));
    case 4 : 
        var prefix$2 = Belt_Option.mapWithDefault(error[0], "a union type", (function (name) {
                return "the union type \"" + (name + "\"");
              }));
        return "While parsing " + (prefix$2 + (" and the field \"kind\", I was expecting either \"alias\" or \"union\" but got \"" + (error[1] + "\"")));
    
  }
}

function decode$1(json) {
  return Misc$BorderTypes.mapErrorResult(errorToString$1, decodeInternal$1(json));
}

var Custom = /* module */Block.localModule([
    "startsWithCapitalLetter",
    "containsInvalidChars",
    "stringDecoder",
    "primitiveDecoder",
    "nameKey",
    "kindKey",
    "kindUnionValue",
    "kindAliasValue",
    "valueKey",
    "constructorsKey",
    "nameDecoder",
    "kindDecoder",
    "aliasDecoder",
    "constructorsDecoder",
    "unionDecoder",
    "decodeInternal",
    "errorToString",
    "decode"
  ], [
    startsWithCapitalLetter,
    containsInvalidChars,
    stringDecoder$1,
    primitiveDecoder,
    nameKey,
    "kind",
    kindUnionValue,
    kindAliasValue,
    valueKey,
    constructorsKey,
    nameDecoder,
    kindDecoder,
    aliasDecoder,
    constructorsDecoder,
    unionDecoder,
    decodeInternal$1,
    errorToString$1,
    decode$1
  ]);

var R = 0;

var O = 0;

exports.R = R;
exports.O = O;
exports.decodeAsResult = decodeAsResult;
exports.Primitive = Primitive;
exports.Custom = Custom;
/* Js_dict Not a pure module */
