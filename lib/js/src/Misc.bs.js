// Generated by BUCKLESCRIPT VERSION 3.1.5, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Belt_Result = require("bs-platform/lib/js/belt_Result.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Types$BorderTypes = require("./Types.bs.js");

function identity(a) {
  return a;
}

function $less$less(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

function $great$great(f, g, x) {
  return Curry._1(f, Curry._1(g, x));
}

function stringToList(s) {
  var _i = s.length - 1 | 0;
  var _l = /* [] */0;
  while(true) {
    var l = _l;
    var i = _i;
    if (i < 0) {
      return l;
    } else {
      _l = /* :: */Block.simpleVariant("::", [
          Caml_string.get(s, i),
          l
        ]);
      _i = i - 1 | 0;
      continue ;
    }
  };
}

function listToString(chars) {
  var strings = List.map((function (x) {
          return $$String.make(1, x);
        }), chars);
  return $$String.concat("", strings);
}

function listToStringMap(l) {
  return List.fold_right((function (param, map) {
                return Curry._3(Types$BorderTypes.StringMap[/* add */3], param[0], param[1], map);
              }), l, Types$BorderTypes.StringMap[/* empty */0]);
}

function dictToStringMap(d) {
  var pairs = $$Array.to_list(Js_dict.entries(d));
  return List.fold_right((function (param, acc) {
                return Curry._3(Types$BorderTypes.StringMap[/* add */3], param[0], param[1], acc);
              }), pairs, Types$BorderTypes.StringMap[/* empty */0]);
}

function toOptionResult(result) {
  if (result.tag) {
    return /* None */0;
  } else {
    return /* Some */Block.simpleVariant("Some", [result[0]]);
  }
}

function mapResult(func, value) {
  return Belt_Result.map(value, func);
}

function andThenResult(func, value) {
  if (value.tag) {
    return /* Error */Block.variant("Error", 1, [value[0]]);
  } else {
    return Curry._1(func, value[0]);
  }
}

function mapErrorResult(func, value) {
  if (value.tag) {
    return /* Error */Block.variant("Error", 1, [Curry._1(func, value[0])]);
  } else {
    return /* Ok */Block.variant("Ok", 0, [value[0]]);
  }
}

function map2Result(func, a, b) {
  if (a.tag) {
    return /* Error */Block.variant("Error", 1, [a[0]]);
  } else if (b.tag) {
    return /* Error */Block.variant("Error", 1, [b[0]]);
  } else {
    return /* Ok */Block.variant("Ok", 0, [Curry._2(func, a[0], b[0])]);
  }
}

function map3Result(func, a, b, c) {
  if (a.tag) {
    return /* Error */Block.variant("Error", 1, [a[0]]);
  } else if (b.tag) {
    return /* Error */Block.variant("Error", 1, [b[0]]);
  } else if (c.tag) {
    return /* Error */Block.variant("Error", 1, [c[0]]);
  } else {
    return /* Ok */Block.variant("Ok", 0, [Curry._3(func, a[0], b[0], c[0])]);
  }
}

function traverseListResults(func, l) {
  return List.fold_right((function (cur, acc) {
                return map2Result((function (curValue, accValue) {
                              return /* :: */Block.simpleVariant("::", [
                                        curValue,
                                        accValue
                                      ]);
                            }), Curry._1(func, cur), acc);
              }), l, /* Ok */Block.variant("Ok", 0, [/* [] */0]));
}

function traverseMapResults(func, m) {
  return Curry._3(Types$BorderTypes.StringMap[/* fold */10], (function (key, cur, acc) {
                return map2Result((function (curValue, accValue) {
                              return Curry._3(Types$BorderTypes.StringMap[/* add */3], key, curValue, accValue);
                            }), Curry._1(func, cur), acc);
              }), m, /* Ok */Block.variant("Ok", 0, [Types$BorderTypes.StringMap[/* empty */0]]));
}

var R = 0;

var D = 0;

exports.R = R;
exports.D = D;
exports.identity = identity;
exports.$less$less = $less$less;
exports.$great$great = $great$great;
exports.stringToList = stringToList;
exports.listToString = listToString;
exports.listToStringMap = listToStringMap;
exports.dictToStringMap = dictToStringMap;
exports.toOptionResult = toOptionResult;
exports.mapResult = mapResult;
exports.andThenResult = andThenResult;
exports.mapErrorResult = mapErrorResult;
exports.map2Result = map2Result;
exports.map3Result = map3Result;
exports.traverseListResults = traverseListResults;
exports.traverseMapResults = traverseMapResults;
/* Js_dict Not a pure module */
